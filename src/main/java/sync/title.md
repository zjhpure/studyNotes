## 公众号(纯洁编程说：chunjie_tech)

## synchronized同步方法的八种使用场景

介绍8种同步方法的访问场景，看看多线程访问同步方法是否还是线程安全的。

#### 1、两个线程同时访问同一个对象的同步方法

分析：这种情况是经典的对象锁中的方法锁，两个线程争夺同一个对象锁，所以会相互等待，是线程安全的。

两个线程同时访问同一个对象的同步方法，是线程安全的。

#### 2、两个线程同时访问两个对象的同步方法

这种场景就是对象锁失效的场景，原因出在访问的是两个对象的同步方法，那么这两个线程分别持有的两个线程的锁，所以是互相不会受限的。加锁的目的是为了让多个线程竞争同一把锁，而这种情况多个线程之间不再竞争同一把锁，而是分别持有一把锁.

所以结论是：两个线程同时访问两个对象的同步方法，是线程不安全的。

代码如下：

Gitee：

[两个线程同时访问两个对象的同步方法](https://gitee.com/zjhpure/studyNotes/tree/master/src/main/java/sync/Condition2.java)

GitHub：

[两个线程同时访问两个对象的同步方法](https://github.com/zjhpure/studyNotes/tree/master/src/main/java/sync/Condition2.java)

分析：

两个线程(thread1、thread2)，访问两个对象(instance1、instance2)的同步方法(method())，两个线程都有各自的锁，不能形成两个线程竞争一把锁的局势，所以这时，synchronized修饰的方法method()和不用synchronized修饰的效果一样(把synchronized关键字去掉，运行结果一样)，所以此时的method()只是个普通方法。

解决：

若要使锁生效，只需将method()方法用static修饰，这样就形成了类锁，多个实例(instance1、instance2)共同竞争一把类锁，就可以使两个线程串行执行了。

#### 3、两个线程同时访问(一个或两个)对象的静态同步方法



#### 4、两个线程分别同时访问(一个或两个)对象的同步方法和非同步方法



#### 5、两个线程访问同一个对象中的同步方法，同步方法又调用一个非同步方法



#### 6、两个线程同时访问同一个对象的不同的同步方法



#### 7、两个线程分别同时访问静态synchronized和非静态synchronized方法



#### 8、同步方法抛出异常后，JVM会自动释放锁的情况



