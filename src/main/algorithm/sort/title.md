## 公众号(纯洁编程说：chunjie_tech)

## Java源码中的Arrays.sort()原理解析

Java源码中为我们封装了排序算法，只需调用Arrays.sort()函数即可完成排序。

在对基本数据类型的数组排序时，Arrays.sort()函数通过调用DualPivotQuicksort.sort()完成排序；

在对非基本数据类型的数组排序时，采用的是TimSort或者归并排序。

#### 分析

当数组长度达到286，并且不存在较多连续相等元素，并且高度结构化时，采用类似TimSort的算法进行排序。

其中用到的TimSort思想是：先拆分出单调递增的run小块，然后将run小块两两合并完成排序，合并时原数组和辅助数组会交替合并。

当数组长度小于INSERTION_SORT_THRESHOLD(即47)时，采用插入排序或双插入排序。

其中，双插入排序的思想是，每次从待排序的数字中取两个数字，并将这两个数字从大到小排好序。

先将大的数字插入到前方已经有序的数组中，然后小的数字直接从大的数字插入的位置开始，向前寻找插入位置。

否则，采用双轴快排进行排序。双轴快排的思想是：每轮选取两个轴pivot1、pivot2(pivot1 < pivot2)，然后以两个轴为分界，将数组分为左中右三个区域。

交换三个区域内的数字，使得三个区域分别属于区间(-∞, pivot1)、[pivot1, pivot2]、(pivot2, +∞)。

然后再对左中右区域不断重复此过程，直至排序完成。

分区后，如果中间区域过大(大于数组长度的4/7)，则将中间区域再次分成三个区域：[pivot1, pivo1]、(pivot1, pivot2)、[pivot2, pivot2]，只让(pivot1, pivot2)区间参与下一轮双轴快排。

如果整个数组中存在较多的相等元素，则不再取两个轴，而是只取一个轴，按照(-∞, pivot)、[pivot, pivot]、(pivot, +∞)进行分区。

然后对左右两个区域不断重复此过程，直至排序完成。

#### 总结

1、当length < 47时，采用插入排序或双插入排序，

2、当length > 286时，并且不存在较多连续相等元素，并且高度结构化时，采用类似TimSort的算法(优化的归并排序，但不是TimSort)，

3、其他情况，包括当47 < length < 286时，采用双轴快排(快速排序)。

4、如果需要排序的数据类型为非基本数据类型，则采用的是TimSort或归并排序

(对非基本类型的排序采用的是TimSort或归并排序，在JDK1.7之前，默认采用归并排序，
JDK1.7及之后，默认采用TimSort，但可以通过设置JVM参数-Djava.util.Arrays.useLegacyMergeSort=true继续使用归并排序)